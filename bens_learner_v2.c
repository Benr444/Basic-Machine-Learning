#pragma config(Sensor, in7,    r_Sensor,       sensorLineFollower)
#pragma config(Sensor, in8,    l_Sensor,       sensorLineFollower)
#pragma config(Sensor, dgtl10, bump,           sensorTouch)
#pragma config(Sensor, dgtl11, l_Sensor_LED,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, r_Sensor_LED,   sensorLEDtoVCC)
#pragma config(Motor,  port1,           r_Motor,       tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port10,          l_Motor,       tmotorVex269_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int mode = 0;
int LINE_THRESHOLD = 1900; //Values above this on line followers are "on the line"
float DURATION = 200; //In milliseconds
int NOMINAL_SPEED = 40;
int time_i = 0;
float turn_k = 0.75;
int in_a_row = 0;
int END_CONDITION_COUNT = 15;
int length = 0;
bool written = false; //True once timeline is filled out
bool executed = false; //Used to keep things running once
int d_time = 1000;
char timeline[40] = {'f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f'};

char write(char code) //Input: direction code to execute, Output: char that represents impact direction correction
{
	clearTimer(T1);
	while (time1[T1] < DURATION) //Move/Turn for the constant duration
	{
		switch (code)
		{
			case 'f': //Forward movement
				motor[l_Motor] = NOMINAL_SPEED;
				motor[r_Motor] = NOMINAL_SPEED;
				break;
			case 'r': //Right turn
				motor[l_Motor] = NOMINAL_SPEED/turn_k;
				motor[r_Motor] = -NOMINAL_SPEED/turn_k;
				in_a_row = 0;
				break;
			case 'l': //Left turn
				motor[l_Motor] = -NOMINAL_SPEED/turn_k;
				motor[r_Motor] = NOMINAL_SPEED/turn_k;
				in_a_row = 0;
				break;
			case 's': //Stop code
				motor[l_Motor] = 0;
				motor[r_Motor] = 0;
				in_a_row = 0;
				return 'E';
				break;
		}
		if (SensorValue[l_Sensor] > LINE_THRESHOLD) //Detect collison, assign
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'r'; //Right correction
		}
		else if (SensorValue[r_Sensor] > LINE_THRESHOLD) //Detect collison, assign
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'l'; //Left correction
		}
		else if ((SensorValue[r_Sensor] > LINE_THRESHOLD) &&(SensorValue[l_Sensor] > LINE_THRESHOLD))
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'l';
		}
	}
	motor[l_Motor] = 0;
	motor[r_Motor] = 0;
	return '_';
}

void reverse(char code) //Reverses an execute move
{
	clearTimer(T1);
	while (time1[T1] < DURATION) //Move/Turn for the constant duration
	{
		switch (code)
		{
			case 'f': //Forward movement
				motor[l_Motor] = -NOMINAL_SPEED;
				motor[r_Motor] = -NOMINAL_SPEED;
				break;
			case 'r': //Right turn
				motor[l_Motor] = -NOMINAL_SPEED/turn_k;
				motor[r_Motor] = NOMINAL_SPEED/turn_k;
				break;
			case 'l': //Left turn
				motor[l_Motor] = NOMINAL_SPEED/turn_k;
				motor[r_Motor] = -NOMINAL_SPEED/turn_k;
				break;
			case 's': //Stop code
				motor[l_Motor] = 0;
				motor[r_Motor] = 0;
				break;
		}
	}
	motor[l_Motor] = 0;
	motor[r_Motor] = 0;
}

bool read(char code)
{
	bool stopped = false; //Set to true when hits stop code
	clearTimer(T1);
	while (time1[T1] < DURATION && stopped == false) //Move/Turn for the constant duration
	{
		switch(code)
		{
			case 'f': //Forward movement
				motor[l_Motor] = NOMINAL_SPEED;
				motor[r_Motor] = NOMINAL_SPEED;
				break;
			case 'r': //Right turn
				motor[l_Motor] = NOMINAL_SPEED/turn_k;
				motor[r_Motor] = -NOMINAL_SPEED/turn_k;
				break;
			case 'l': //Left turn
				motor[l_Motor] = -NOMINAL_SPEED/turn_k;
				motor[r_Motor] = NOMINAL_SPEED/turn_k;
				break;
			case 's': //Stop code
				motor[l_Motor] = 0;
				motor[r_Motor] = 0;
				stopped = true;
		}
	}
	motor[l_Motor] = 0;
	motor[r_Motor] = 0;
	return stopped;
}

void read_all()
{
	for(int read_i = 0; read_i < length; read_i++)
	{
		delay(d_time);
		if (read(timeline[read_i]) == true)
		{
			read_i = length; //Stop the loop
		}
	}
}

task main()
{
	while (true)
	{
		SensorValue[l_Sensor_LED] = (SensorValue[l_Sensor] > LINE_THRESHOLD);
		SensorValue[r_Sensor_LED] = (SensorValue[r_Sensor] > LINE_THRESHOLD);
		if (mode == 0) //If auto is selected
		{
			/*Timeline data is encoded as follows
				-l: left turn
				-r: right turn
				-f: no turn, forward motion
				-s: stop motion
			*/
			length = (sizeof(timeline))/(sizeof(timeline[0])); //Length of timeline
			if (written == false)
			{
				for (time_i = 0; time_i < length; time_i++)	//For each timeline event
				{
					delay(d_time);
					char correction = write(timeline[time_i]); //Roll forwards until we detect a correction code or hit the duration cap
					if (correction == '_') //If it returns a forward code
					{
						in_a_row += 1; //Up the in-a-row count for forward motion
						if (in_a_row >= END_CONDITION_COUNT) //If we've reached a certain number of forward movements
						{
							written = true; //Switch to other mode
							time_i = length; //End this for loop
							motor[l_Motor] = 0;
							motor[r_Motor] = 0;
							timeline[time_i] = 's'; //Insert stop code
						}
					}
					else //If it returns a real correction code code
					{
						in_a_row = 0; //Broke the chain of forwards
						reverse(timeline[time_i]); //Undo the last move
						timeline[time_i] = correction; //Insert the new correction
						time_i -= 1; //Reverse time by 1, so we can redo with correct moves
					}
				} //End timeline for
				written = true; //Finished reading at end of timeline
				timeline[length - 1] = 's'; //Final value must always be a stop
			} //End written if
			else
			{
				if (SensorValue[bump] == 1) //When the button is pushed
				{
					read_all(); //Replay the entire timeline, no feedback
				}
			}
		} //End auto if
		else if (mode == 1) //If in manual
		{
			//----Begin Remote Control
			if (abs(vexRT[Ch2]) > 12.7) //If the axis is out of the middle deadzone
			{
				motor[r_Motor] = vexRT[Ch2]; //Set the axis value to the motor
			}
			else //If we're in the deadzone
			{
				motor[r_Motor] = 0; //Stop the robot
			}

			if ( abs(vexRT[Ch3]) > 12.7 ) //See above comments for explanation
			{
				motor[l_Motor] = vexRT[Ch3];
			}
			else
			{
				motor[l_Motor] = 0;
			}
			//----End Remote Control
		}
		else if (mode == 2)
		{
			if (SensorValue[bump] == 1 && executed == false)
			{
					executed = true;
					read('f');
			}
			else if (SensorValue[bump] == 0)
			{
				executed = false;
			}
		}
		else
		{
			//Nothing
		}//End of mode if
	} //End of while loop
} //End of task main
