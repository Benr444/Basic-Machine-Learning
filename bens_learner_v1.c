#pragma config(Sensor, in7,    r_Sensor,       sensorLineFollower)
#pragma config(Sensor, in8,    l_Sensor,       sensorLineFollower)
#pragma config(Sensor, dgtl8,  bump,           sensorTouch)
#pragma config(Sensor, dgtl11, l_Sensor_LED,   sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, r_Sensor_LED,   sensorLEDtoVCC)
#pragma config(Motor,  port1,           r_Motor,       tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port10,          l_Motor,       tmotorVex269_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LINE_THRESHOLD = 1900; //Values above this on line followers are "on the line"
int mode = 0;
float DURATION = 750; //In milliseconds
int NOMINAL_SPEED = 25;
char timeline[40] = {'f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f','f'};
int time_i = 0;
float turn_k = 1.5;
int in_a_row = 0;
int END_CONDITION_COUNT = 7;
int length = 0;

/*
void insertMove()
{
	int length = (sizeof(timeline))/(sizeof(timeline[0]));
	int k = sizeof(time_i);
	char a[time_i]; //First half
	char b[length - time_i]; //Second half
	for (int temp = 0; temp < length; temp++)
	{
		if (temp <= time_i) //In first half
		{
			a[temp] = timeline[temp];
		}
		else //In second half
		{
			b[temp] = timeline[temp];
		}
	}
	char c[] = {corrective_code};
	timeline = a + c + b; //Concat the three arrays together, essentially inserting the corrective code ahead of time_i
}
*/

void reverse(char code) //Reverses an execute move
{
	in_a_row = 0;
	clearTimer(T1);
	while (time1[T1] < DURATION) //Move/Turn for the constant duration
	{
		switch (code)
		{
			case 'f': //Forward movement
				motor[l_Motor] = -NOMINAL_SPEED;
				motor[r_Motor] = -NOMINAL_SPEED;
				break;
			case 'r': //Right turn
				motor[l_Motor] = -NOMINAL_SPEED/turn_k;
				motor[r_Motor] = NOMINAL_SPEED/turn_k;
				break;
			case 'l': //Left turn
				motor[l_Motor] = NOMINAL_SPEED/turn_k;
				motor[r_Motor] = -NOMINAL_SPEED/turn_k;
				break;
			case 's': //Stop code
				motor[l_Motor] = 0;
				motor[r_Motor] = 0;
				break;
		}
	}
}

char execute(char code) //Input: direction code to execute, Output: char that represents impact direction correction
{
	if(timeline[time_i] == 'f')
	{
		in_a_row += 1;
	}
	clearTimer(T1);
	while (time1[T1] < DURATION) //Move/Turn for the constant duration
	{
		switch (code)
		{
			case 'f': //Forward movement
				motor[l_Motor] = NOMINAL_SPEED;
				motor[r_Motor] = NOMINAL_SPEED;
				break;
			case 'r': //Right turn
				motor[l_Motor] = NOMINAL_SPEED/turn_k;
				motor[r_Motor] = -NOMINAL_SPEED/turn_k;
				in_a_row = 0;
				break;
			case 'l': //Left turn
				motor[l_Motor] = -NOMINAL_SPEED/turn_k;
				motor[r_Motor] = NOMINAL_SPEED/turn_k;
				in_a_row = 0;
				break;
			case 's': //Stop code
				motor[l_Motor] = 0;
				motor[r_Motor] = 0;
				in_a_row = 0;
				return 'E';
				break;
		}
		if (SensorValue[l_Sensor] > LINE_THRESHOLD) //Detect collison, assign
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'r'; //Right correction
		}
		else if (SensorValue[r_Sensor] > LINE_THRESHOLD) //Detect collison, assign
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'l'; //Left correction
		}
		else if ((SensorValue[r_Sensor] > LINE_THRESHOLD) &&(SensorValue[l_Sensor] > LINE_THRESHOLD))
		{
			motor[l_Motor] = 0;
			motor[r_Motor] = 0;
			return 'l';
		}
	}
	motor[l_Motor] = 0;
	motor[r_Motor] = 0;
	return '_';
}

void replay()
{
	for(int time_is = 0; time_is < length; time_is++)
	{
		clearTimer(T1);
		while (time1[T1] < DURATION) //Move/Turn for the constant duration
		{
			switch(timeline[time_is])
			{
				case 'f': //Forward movement
					motor[l_Motor] = NOMINAL_SPEED;
					motor[r_Motor] = NOMINAL_SPEED;
					break;
				case 'r': //Right turn
					motor[l_Motor] = NOMINAL_SPEED/turn_k;
					motor[r_Motor] = -NOMINAL_SPEED/turn_k;
					break;
				case 'l': //Left turn
					motor[l_Motor] = -NOMINAL_SPEED/turn_k;
					motor[r_Motor] = NOMINAL_SPEED/turn_k;
					break;
				case 's': //Stop code
					motor[l_Motor] = 0;
					motor[r_Motor] = 0;
					time_is = length;
			}
		}

	}
}

task main()
{
	while (true)
	{
		SensorValue[l_Sensor_LED] = (SensorValue[l_Sensor] > LINE_THRESHOLD);
		SensorValue[r_Sensor_LED] = (SensorValue[r_Sensor] > LINE_THRESHOLD);

		/*
		if (SensorValue[l_Sensor] > LINE_THRESHOLD)
		{SensorValue[l_Sensor_LED] = 1;} else {SensorValue[l_Sensor_LED] = 0;}
		if (SensorValue[r_Sensor] > LINE_THRESHOLD)
		{SensorValue[r_Sensor_LED] = 1;} else {SensorValue[r_Sensor_LED] = 0;}
		*/
		switch (mode)
		{
			case 0:
				if (in_a_row < END_CONDITION_COUNT) //If we haven't reached the end of the maze
				{
					int length = (sizeof(timeline))/(sizeof(timeline[0]));
					for (time_i = 0; time_i < length; time_i++)
					{
						if (in_a_row < END_CONDITION_COUNT)
						{
							char response = execute(timeline[time_i]); //Execute the move and grab the response
							if (response == '_')
							{
								//Do nothing
							}
							else if (response == 'E')
							{
								break; //AAAAAAAAAAAAAAAA WHAT DID YOU DO! CHRIST, THERE'S AN ERROR CODE BEING EXECUTED ON THE TIMELINE!
								//CRAP, BATTEN DOWN THE REGISTERS! SEAL OFF THE RAM! HOLY HELLS, THIS PROGRAM IS GOING DOWN!
								//ABORT, ABORT! MAYDAY, DO YOU HEAR ME I/O PORT?! WE NEED ASSISTANCE HERE!
								//[/end of transmission]
								//...
							}
							else
							{
								reverse(timeline[time_i]); //Undo the last move
								timeline[time_i] = response; //Insert the corrective move into the timeline
								time_i -= 1; //Undo the index
							}
						}
						else
						{
								timeline[time_i] = 's'; //Insert stop code into timeline
								motor[r_Motor] = 0;
								motor[l_Motor] = 0;
								time_i = length;  //Stop the loop
						}
					} //End of for loop

				}
				else //if we HAVE reached the end of the maze
				{
					if (SensorValue[bump] == 1) //When the bump button is pressed
					{
						replay();
					}
				}
			break;
			case 1:
				//----Begin Remote Control
				if (abs(vexRT[Ch2]) > 12.7) //If the axis is out of the middle deadzone
				{
					motor[r_Motor] = vexRT[Ch2]; //Set the axis value to the motor
				}
				else //If we're in the deadzone
				{
					motor[r_Motor] = 0; //Stop the robot
				}

				if ( abs(vexRT[Ch3]) > 12.7 ) //See above comments for explanation
				{
					motor[l_Motor] = vexRT[Ch3];
				}
				else
				{
					motor[l_Motor] = 0;
				}
				//----End Remote Control
			break;

		}
	} //End of while loop
} //End of task main
