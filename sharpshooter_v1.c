#pragma config(Sensor, in1,    angler,         sensorPotentiometer)
#pragma config(Sensor, in2,    rangeSelector,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  butt,           sensorTouch)
#pragma config(Sensor, dgtl2,  shortDis,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  longDis,        sensorDigitalIn)
#pragma config(Sensor, dgtl4,  center,         sensorDigitalIn)
#pragma config(Motor,  port1,           angleMotor1,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           flywheel0,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           flywheel1,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           flywheel2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           flywheel3,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          angleMotor2,   tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Needs to save coefficient history
float a = 1;
float b = 2;
float c = 3;
float INITIALPOT = 0;
float DEGPERTICK = 0.06471306;
int NOMINALPOWER = 127;
float distance = 10;
int shotsTaken = 0;
int rampTime = 15000;
float learningRate = .015;
float anglingPConstant = 127/12;
float myAngle = 0;

float getAngle()
{
	return (SensorValue[angler] - INITIALPOT) * DEGPERTICK;
}

void toAngle(float angle)
{
		float err = angle - getAngle();
		while(abs(err) > 2)
		{
			motor[angleMotor1] = err * anglingPConstant;
			motor[angleMotor2] = err * anglingPConstant;
			err = angle - getAngle();
		}
		motor[angleMotor1] = 0;
		motor[angleMotor2] = 0;
}
void setMotors(int power)
{
	motor[flywheel0] = power;
	motor[flywheel1] = power;
	motor[flywheel2] = power;
	motor[flywheel3] = power;
}

void rampMotors(int power)
{
	int dPower = power - motor[flywheel0];
	int lastTime = 0;
	float delayTime = rampTime/20;
	for (int i = 0; i < 20; i++)
	{
		delay(delayTime);
		setMotors(motor[flywheel0] + dPower/20);
	}
}

float calcAngle(float dist)
{
	return a * dist * dist + b * dist + c;
}

void updateCoef(int error)
{
	a = a + a * learningRate * error;
	b = b + b * learningRate * error;
	c = c + c * learningRate * error;
}

task main()
{
	while (false)
	{
		//motor[angleMotor1] = vexRT[Ch2];
		//motor[angleMotor2] = vexRT[Ch2];
		//toAngle((vexRT[Ch2]/127) * 45);
	}
	while (true)
	{
		if (SensorValue[butt] == 1)
		{
			toAngle(45);
		}
		else
		{
			toAngle(0);
		}
		myAngle = getAngle();
	}
	while (false)
	{
		setMotors(NOMINALPOWER);
		if(SensorValue[shortDis]==1)
		{
			updateCoef(1);
			toAngle(calcAngle(distance));
			shotsTaken++;
		}
		if(SensorValue[longDis]==1)
		{
			updateCoef(-1);
			toAngle(calcAngle(distance));
			shotsTaken++;
		}
		if(SensorValue[center]==1)
		{
			updateCoef(0);
			toAngle(calcAngle(distance));
			shotsTaken++;
		}
	}
}
